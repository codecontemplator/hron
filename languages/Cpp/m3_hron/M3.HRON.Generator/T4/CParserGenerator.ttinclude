<#@ include file="CHeader.ttinclude" #>


<#
    
    var defaultState = model
        .FirstOrDefault (ps => ps.IsDefault) ?? new ParserState ("<DefaultState>", isDefault:true);
#>

enum ParserState
{
<#
foreach (var parserState in model)
{
#>
    PS_<#=parserState.Name#>,
<#
}
#>
};

enum ParserStateTransition
{
<#
foreach (var parserState in model)
{
    foreach (var name in parserState.AllStates(defaultState).SelectMany (nps => nps.Names))
    {
#>
        PST_From_<#=parserState.Name#>__To_<#=name#>,
<#
    }
}
#>
};

enum ParserStateChoice
{
<#
foreach (var parserState in model)
{
    foreach (var nextParserState in parserState.ChoiceStates(defaultState))
    {
#>
        PSC_From_<#=parserState.Name#>__Choose_<#=string.Join ("_", nextParserState.Names)#>,
<#
    }
}
#>
};

enum ParserResult
{
    PR_Error   ,
    PR_Continue,
};

/*
    sealed partial class Scanner
    {
        ParserState State = default (ParserState);

        partial void Partial_BeginLine (SubString ss);
        partial void Partial_EndLine ();

        partial void Partial_StateChoice (
            char                    current     ,
            ParserStateChoice       choice      ,
            ParserState             from        ,
            ref ParserState         to
            );

        partial void Partial_StateTransition (
            char                    current     ,
            ParserState             from        ,
            ParserState             to          ,
            ParserStateTransition   transition  ,
            ref ParserResult        result      
            );

        partial void Partial_AcceptEndOfStream ();
                
        public ParserResult AcceptEndOfStream ()
        {
            Partial_AcceptEndOfStream ();
            return ParserResult.Continue;             
        }

        public ParserResult AcceptLine (SubString ss)
        {
            var result = ParserResult.Continue;

            Partial_BeginLine (ss);

            var bs = ss.BaseString;
            var begin = ss.Begin;
            var end = ss.End;

            for (var iter = begin; (iter < end) & (result == ParserResult.Continue); ++iter)
            {
                result = AcceptCharacter (bs[iter]);
            }

            AcceptEndOfLine ();

            Partial_EndLine ();

            return result;
        }

        const char EndOfStream = (char)0;

        ParserResult AcceptEndOfLine ()
        {
            var result = ParserResult.Continue; 
            switch (State)
            {
<#
    foreach (var parserState in model.Where (ps => ps.Any (nps => nps.IsTerminator)))
    {
#>
            case ParserState.<#=parserState.Name#>:
<#
        var nextParserState = parserState.First (nps => nps.IsTerminator);
        if (nextParserState.IsChoice)
        {
#>
                Partial_StateChoice (
                    EndOfStream,
                    ParserStateChoice.From_<#=parserState.Name#>__Choose_<#=string.Join ("_", nextParserState.Names)#>,
                    ParserState.<#=parserState.Name#>,
                    ref State
                    );

                switch (State)
                {
<#
        foreach (var name in nextParserState.Names)
        {
#>
                case ParserState.<#=name#>:
                    Partial_StateTransition (
                        EndOfStream,
                        ParserState.<#=parserState.Name#>,
                        State,
                        ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                        ref result
                        );
                    break;
<#
        }
#>
                    default:
                        result = ParserResult.Error;
                        break;
                }
<#
        }
        else
        {
            var name = nextParserState.Names[0]; 
#>
                State = ParserState.<#=name#>; 
                Partial_StateTransition (
                    EndOfStream,
                    ParserState.<#=parserState.Name#>,
                    ParserState.<#=name#>,
                    ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                    ref result
                    );

<#
        }

    if (nextParserState.HandOver)
    {
#>
                if (result == ParserResult.Continue)
                {
                    result = AcceptCharacter (EndOfStream);    
                }   
<#
    }
#>
                break;
<#
    }
#>
            }

            return result;
        }

        ParserResult AcceptCharacter (char ch)
        {
            var result = ParserResult.Continue; 
            switch (State)
            {
<#
    foreach (var parserState in model)
    {
#>
            case ParserState.<#=parserState.Name#>:
                switch (ch)
                {
<#
    foreach (var nextParserState in parserState.NextStates (defaultState))
    {
        if (nextParserState.IsDefaultCase)
        {
#>
                default:
<#
        }
        else
        {
            foreach (var ch in nextParserState.Characters)
            {
#>
                case <#=GetCase(ch)#>:
<#
            }
        }
        if (nextParserState.IsChoice)
        {
#>
                    Partial_StateChoice (
                        ch,
                        ParserStateChoice.From_<#=parserState.Name#>__Choose_<#=string.Join ("_", nextParserState.Names)#>,
                        ParserState.<#=parserState.Name#>,
                        ref State
                        );

                    switch (State)
                    {
<#
        foreach (var name in nextParserState.Names)
        {
#>
                    case ParserState.<#=name#>:
                        Partial_StateTransition (
                            ch,
                            ParserState.<#=parserState.Name#>,
                            State,
                            ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                            ref result
                            );
                        break;
<#
        }
#>
                    default:
                        result = ParserResult.Error;
                        break;
                }
<#
        }
        else
        {
            var name = nextParserState.Names[0]; 
#>
                    State = ParserState.<#=name#>; 
                    Partial_StateTransition (
                        ch,
                        ParserState.<#=parserState.Name#>,
                        ParserState.<#=name#>,
                        ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                        ref result
                        );
<#
        }
    if (nextParserState.HandOver)
    {
#>
                    if (result == ParserResult.Continue)
                    {
                        result = AcceptCharacter (ch);    
                    }   
<#
    }
#>
                    break;
<#
    }
#>    
                }
                break;
<#
    }
#>
            default:
                result = ParserResult.Error;
                break;
            }

            return result;
        }
    }

*/
<#@ include file="ParserGenerator.ttinclude"#>