<#@ include file="Header.ttinclude" #>

// ReSharper disable InconsistentNaming

<#

    var model = new []
        {
            new ParserState ("Error", isDefault:true)     
            {
                Next        (DefaultCase        , "Error"       ),
            },

            new ParserState ("Indention")     
            {
                Next        ("\t"       , "Indention"                   ),
                HandOver    (DefaultCase, "TagExpected" 
                                        , "ValueLine" 
                                        , "OtherValueLine"      
                                        , "Error"                       ),
            },

            new ParserState ("TagExpected")     
            {
                Terminator  (NoCase     , "EndOfEmptyTag"       ),
                Next        ("@"        , "ObjectTag"           ),
                Next        ("="        , "ValueTag"            ),
                Next        ("#"        , "CommentTag"          ),
                Next        ("\t "      , "EmptyTag"            ),
            },

            new ParserState ("ObjectTag")     
            {
                Terminator  (NoCase     , "EndOfObjectTag"      ),
                Next        (DefaultCase, "ObjectTag"           ),
            },

            new ParserState ("ValueTag")     
            {
                Terminator  (NoCase     , "EndOfValueTag"       ),
                Next        (DefaultCase, "ValueTag"            ),
            },

            new ParserState ("EmptyTag")     
            {
                Terminator  (NoCase     , "EndOfEmptyTag"       ),
                Next        ("\t "      , "EmptyTag"            ),
            },

            new ParserState ("CommentTag")     
            {
                Terminator  (NoCase     , "EndOfCommentTag"     ),
                Next        (DefaultCase, "CommentTag"          ),
            },

            new ParserState ("EndOfObjectTag")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

            new ParserState ("EndOfEmptyTag")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

            new ParserState ("EndOfValueTag")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

            new ParserState ("EndOfCommentTag")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

            new ParserState ("ValueLine")     
            {
                Terminator  (NoCase     , "EndOfValueLine"      ),
                Next        (DefaultCase, "ValueLine"           ),
            },

            new ParserState ("OtherValueLine")     
            {
                Terminator  (NoCase     , "EndOfEmptyLine"      ),
                Next        ("#"        , "CommentLine"         ),
                Next        (" "        , "EmptyLine"           ),
            },

            new ParserState ("CommentLine")     
            {
                Terminator  (NoCase     , "EndOfCommentLine"    ),
                Next        (DefaultCase, "CommentLine"         ),
            },

            new ParserState ("EmptyLine")     
            {
                Terminator  (NoCase     , "EndOfEmptyLine"      ),
                Next        ("\t "      , "EmptyLine"           ),
            },

            new ParserState ("EndOfValueLine")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

            new ParserState ("EndOfCommentLine")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

            new ParserState ("EndOfEmptyLine")     
            {
                HandOver    (DefaultCase, "Indention"           ),
            },

        };

#>

<#
    
    var defaultState = model
        .FirstOrDefault (ps => ps.IsDefault) ?? new ParserState ("<DefaultState>", isDefault:true);
#>

namespace M3.HRON.Generator.Parser
{
    enum ParserState
    {
<#
    foreach (var parserState in model)
    {
#>
        <#=parserState.Name#>,
<#
    }
#>
    }

    enum ParserStateTransition
    {
<#
    foreach (var parserState in model)
    {
        foreach (var name in parserState.AllStates(defaultState).SelectMany (nps => nps.Names))
        {
#>
            From_<#=parserState.Name#>__To_<#=name#>,
<#
        }
    }
#>
    }

    enum ParserStateChoice
    {
<#
    foreach (var parserState in model)
    {
        foreach (var nextParserState in parserState.ChoiceStates(defaultState))
        {
#>
            From_<#=parserState.Name#>__Choose_<#=string.Join ("_", nextParserState.Names)#>,
<#
        }
    }
#>
    }

    enum ParserResult
    {
        Error   ,
        Continue,
    }

    sealed partial class Scanner
    {
        ParserState State = default (ParserState);

        partial void Partial_BeginLine (string l);
        partial void Partial_EndLine (string l);

        partial void Partial_StateChoice (
            char                    current     ,
            ParserStateChoice       choice      ,
            ParserState             from        ,
            ref ParserState         to
            );

        partial void Partial_StateTransition (
            char                    current     ,
            ParserState             from        ,
            ParserState             to          ,
            ParserStateTransition   transition  ,
            ref ParserResult        result      
            );
                
        public ParserResult AcceptLine (string l)
        {
            l = l ?? "";

            var result = ParserResult.Continue;
            var length = l.Length;

            Partial_BeginLine (l);

            for (var iter = 0; (iter < length) & (result == ParserResult.Continue); ++iter)
            {
                result = AcceptCharacter (l[iter]);
            }

            AcceptEndOfLine ();

            Partial_EndLine (l);

            return result;
        }

        const char EndOfStream = (char)0;

        ParserResult AcceptEndOfLine ()
        {
            var next = default (ParserState);
            var result = ParserResult.Continue; 
            switch (State)
            {
<#
    foreach (var parserState in model.Where (ps => ps.Any (nps => nps.IsTerminator)))
    {
#>
            case ParserState.<#=parserState.Name#>:
<#
        var nextParserState = parserState.First (nps => nps.IsTerminator);
        if (nextParserState.IsChoice)
        {
#>
                Partial_StateChoice (
                    EndOfStream,
                    ParserStateChoice.From_<#=parserState.Name#>__Choose_<#=string.Join ("_", nextParserState.Names)#>,
                    ParserState.<#=parserState.Name#>,
                    ref next
                    );

                switch (next)
                {
<#
        foreach (var name in nextParserState.Names)
        {
#>
                case ParserState.<#=name#>:
                    Partial_StateTransition (
                        EndOfStream,
                        ParserState.<#=parserState.Name#>,
                        next,
                        ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                        ref result
                        );
                    break;
<#
        }
#>
                    default:
                        result = ParserResult.Error;
                        break;
                }
<#
        }
        else
        {
            var name = nextParserState.Names[0]; 
#>
                next = ParserState.<#=name#>; 
                Partial_StateTransition (
                    EndOfStream,
                    ParserState.<#=parserState.Name#>,
                    next,
                    ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                    ref result
                    );

<#
        }
    if (nextParserState.HandOver)
    {
#>
                if (result == ParserResult.Continue)
                {
                    AcceptEndOfLine ();    
                }   
<#
    }
#>
                break;
<#
    }
#>
            }

            State = next;

            return result;
        }

        ParserResult AcceptCharacter (char ch)
        {
            var next = default (ParserState);
            var result = ParserResult.Continue; 
            switch (State)
            {
<#
    foreach (var parserState in model)
    {
#>
            case ParserState.<#=parserState.Name#>:
                switch (ch)
                {
<#
    foreach (var nextParserState in parserState.NextStates (defaultState))
    {
        if (nextParserState.IsDefault)
        {
#>
                default:
<#
        }
        else
        {
            foreach (var ch in nextParserState.Characters)
            {
#>
                case <#=GetCase(ch)#>:
<#
            }
        }
        if (nextParserState.IsChoice)
        {
#>
                    Partial_StateChoice (
                        EndOfStream,
                        ParserStateChoice.From_<#=parserState.Name#>__Choose_<#=string.Join ("_", nextParserState.Names)#>,
                        ParserState.<#=parserState.Name#>,
                        ref next
                        );

                    switch (next)
                    {
<#
        foreach (var name in nextParserState.Names)
        {
#>
                    case ParserState.<#=name#>:
                        Partial_StateTransition (
                            EndOfStream,
                            ParserState.<#=parserState.Name#>,
                            next,
                            ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                            ref result
                            );
                        break;
<#
        }
#>
                    default:
                        result = ParserResult.Error;
                        break;
                }
<#
        }
        else
        {
            var name = nextParserState.Names[0]; 
#>
                    next = ParserState.<#=name#>; 
                    Partial_StateTransition (
                        ch,
                        ParserState.<#=parserState.Name#>,
                        next,
                        ParserStateTransition.From_<#=parserState.Name#>__To_<#=name#>,
                        ref result
                        );
<#
        }
    if (nextParserState.HandOver)
    {
#>
                    if (result == ParserResult.Continue)
                    {
                        AcceptCharacter (ch);    
                    }   
<#
    }
#>
                    break;
<#
    }
#>    
                }
                break;
<#
    }
#>
            default:
                result = ParserResult.Error;
                break;
            }

            State = next;

            return result;
        }

    }


}

<#+

    const string DefaultCase    = "<<DefaultCase>>";
    const string NoCase         = "<<NoCase>>";

    sealed class ParserState : BaseContainer<Root, NextParserState>
    {
        public readonly string  Name        ;
        public readonly bool    IsDefault   ;

        public ParserState (string name, bool isDefault = false)
        {
            Name        = name ?? S_NoName  ;
            IsDefault   = isDefault         ; 
        }

        public IEnumerable<NextParserState> NextStates (ParserState defaultState)
        {
            return AllStates (defaultState).Where (nsp => !nsp.IsNoCase);
        }

        public IEnumerable<NextParserState> AllStates (ParserState defaultState)
        {
            foreach (var nextParserState in this.Where (nsp => !nsp.IsDefault))
            {
                yield return nextParserState;
            }

            var defaultCase = this.FirstOrDefault (nsp => nsp.IsDefault);
            if (defaultCase != null)
            {
                yield return defaultCase;
            }
            else
            {
                yield return Next (DefaultCase, defaultState.Name);
            }
        }

        public IEnumerable<NextParserState> ChoiceStates (ParserState defaultState)
        {
            return AllStates (defaultState).Where (nsp => nsp.IsChoice);
        }

    }

    sealed class NextParserState : BaseEntity<ParserState>
    {
        public readonly string[]    Names       ;
        public readonly string      Characters  ;
        public readonly bool        IsTerminator;
        public readonly bool        HandOver    ;

        public NextParserState (
            string[] names, 
            string characters, 
            bool isTerminator, 
            bool handOver
            )
        {
            Names       = names         ?? new string [0]       ;
            if (Names.Length < 1)
            {
                Names = new [] {S_NoName};
            }
            Characters  = characters    ?? ""                   ;
            IsTerminator= isTerminator                          ;
            HandOver    = handOver                              ;
        }

        public bool IsNoCase
        {
            get
            {
                return ReferenceEquals (Characters, NoCase);
            }
        }

        public bool IsChoice 
        {
            get
            {
                return Names.Length > 1;
            }
        }

        public bool IsDefault
        {
            get
            {
                return ReferenceEquals (Characters, DefaultCase);
            }
        }
    }

    static NextParserState Next (string characters, params string[] names)
    {
        return new NextParserState (names, characters, isTerminator:false, handOver:false);
    }

    static NextParserState HandOver (string characters, params string[] names)
    {
        return new NextParserState (names, characters, isTerminator:false, handOver:true);
    }

    static NextParserState Terminator (string characters, params string[] names)
    {
        return new NextParserState (names, characters, isTerminator:true, handOver:false);
    }

    static string GetCase (char ch)
    {
        switch (ch)
        {
        case '\t':
            return "'\\t'";
        case '\r':
            return "'\\r'";
        case '\n':
            return "'\\n'";
        default:
            return "'" + ch + "'";
        }
    }


#>