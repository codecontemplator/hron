<#@ include file="Header.ttinclude" #>

// ReSharper disable InconsistentNaming

<#

    var model = new []
        {
            new ParserState ("Error", isDefault:true    )     
            {
                new NextParserState ("Error"        , ""    ),
            },

            new ParserState ("TagExpected")     
            {
                new NextParserState ("TagExpected"  , "\t"  ),
                new NextParserState ("ObjectTag"    , "@"   ),
                new NextParserState ("ValueTag"     , "="   ),
                new NextParserState ("CommentTag"   , "#"   ),
                new NextParserState ("EmptyTag"     , " "   ),
                new NextParserState ("EndOfEmptyTag", "\r\n"),
            },

            new ParserState ("ObjectTag")     
            {
                new NextParserState ("EndOfObjectTag"   , "\r\n"),
                new NextParserState ("ObjectTag"                ),
            },

            new ParserState ("ValueTag")     
            {
                new NextParserState ("EndOfValueTag", "\r\n"),
                new NextParserState ("ValueTag"             ),
            },

            new ParserState ("EmptyTag")     
            {
                new NextParserState ("EndOfEmptyTag", "\r\n"),
                new NextParserState ("EmptyTag"     , "\t " ),
            },

            new ParserState ("CommentTag")     
            {
                new NextParserState ("EndOfCommentTag"  , "\r\n"),
                new NextParserState ("CommentTag"               ),
            },

            new ParserState ("EndOfObjectTag")     
            {
                new NextParserState ("EndOfObjectTag"   , "\n"  ),
                new NextParserState ("TagExpected"              ),
            },

            new ParserState ("EndOfEmptyTag")     
            {
                new NextParserState ("EndOfEmptyTag"    , "\n"  ),
                new NextParserState ("TagExpected"              ),
            },

            new ParserState ("EndOfValueTag")     
            {
                new NextParserState ("EndOfValueTag"    , "\n"  ),
                new NextParserState ("ValueExpected"            ),
            },

            new ParserState ("EndOfCommentTag")     
            {
                new NextParserState ("EndOfCommentTag"  , "\n"  ),
                new NextParserState ("TagExpected"              ),
            },

            new ParserState ("ValueExpected")     
            {
                new NextParserState ("ValueExpected"    , "\t"  ),
                new NextParserState ("CommentLine"      , "#"   ),
                new NextParserState ("EndOfEmptyLine"   , "\r\n"),
                new NextParserState ("ValueLine"                ),
            },

            new ParserState ("CommentLine")     
            {
                new NextParserState ("EndOfCommmentLine"    , "\r\n"),
                new NextParserState ("CommentLine"                  ),
            },

            new ParserState ("ValueLine")     
            {
                new NextParserState ("EndOfValueLine"       , "\r\n"),
                new NextParserState ("ValueLine"                    ),
            },

            new ParserState ("EndOfEmptyLine")     
            {
                new NextParserState ("EndOfEmptyLine"       , "\n"  ),
                new NextParserState ("TagExpected"                  ),
            },

            new ParserState ("EndOfCommmentLine")     
            {
                new NextParserState ("EndOfCommmentLine"    , "\n"  ),
                new NextParserState ("ValueExpected"                ),
            },

            new ParserState ("EndOfValueLine")     
            {
                new NextParserState ("EndOfValueLine"       , "\n"  ),
                new NextParserState ("TagExpected"                  ),
            },

        };

#>

<#

    var defaultState = model
        .FirstOrDefault (ps => ps.IsDefault) ?? new ParserState ("<DefaultState>", isDefault:true);
#>

namespace M3.HRON.Generator.Parser
{
    enum ParserState
    {
<#
    foreach (var parserState in model)
    {
#>
        <#=parserState.Name#>,
<#
    }
#>
    }

    enum ParserStateTransition
    {
<#
    foreach (var parserState in model)
    {
        foreach (var nextParserState in parserState.NextStates(defaultState))
        {
#>
            From_<#=parserState.Name#>__To_<#=nextParserState.Name#>,
<#
        }
    }
#>
    }

    enum ParserResult
    {
        Error   ,
        Continue,
        Done    ,
    }

    sealed partial class Scanner
    {
        ParserState State = default (ParserState);

        partial void Partial_ComputeNewState (
            char                    current     ,
            ParserState             from        ,
            ParserState             to          ,
            ParserStateTransition   transition  ,
            ref ParserResult        result      ,
            ref ParserState         newState
            );
                
        public ParserResult AcceptLine (string l)
        {
            l = l ?? "";

            for (var iter = 0; iter < l.Length; ++iter)
            {
                switch (AcceptCharacter (l[iter]))
                {
                case ParserResult.Continue:
                    break;
                case ParserResult.Done:
                    return ParserResult.Done;
                case ParserResult.Error:
                default:
                    return ParserResult.Error;
                }
            }
            return ParserResult.Continue;
        }

        public ParserResult AcceptCharacter (char ch)
        {
            var result = ParserResult.Continue; 
            switch (State)
            {
<#
    foreach (var parserState in model)
    {
#>
            case ParserState.<#=parserState.Name#>:
                switch (ch)
                {
<#
    foreach (var nextParserState in parserState.NextStates (defaultState))
    {
        if (nextParserState.IsDefault)
        {
#>
                default:
                    Partial_ComputeNewState (
                        ch,
                        ParserState.<#=parserState.Name#>,
                        ParserState.<#=nextParserState.Name#>,
                        ParserStateTransition.From_<#=parserState.Name#>__To_<#=nextParserState.Name#>,
                        ref result,
                        ref State
                        );
                    break;
<#
        }
        else
        {
            foreach (var ch in nextParserState.Characters)
            {
#>
                case <#=GetCase(ch)#>:
<#
            }
#>
                    Partial_ComputeNewState (
                        ch,
                        ParserState.<#=parserState.Name#>,
                        ParserState.<#=nextParserState.Name#>,
                        ParserStateTransition.From_<#=parserState.Name#>__To_<#=nextParserState.Name#>,
                        ref result,
                        ref State
                        );
                    break;
<#
        }
    }
#>    
                }
                break;
<#
    }
#>
            default:
                result = ParserResult.Error;
                break;
            }

            return result;
        }

    }


}

<#+

    sealed class ParserState : BaseContainer<Root, NextParserState>
    {
        public readonly string  Name        ;
        public readonly bool    IsDefault   ;

        public ParserState (string name, bool isDefault = false)
        {
            Name        = name ?? S_NoName  ;
            IsDefault   = isDefault         ; 
        }

        public IEnumerable<NextParserState> NextStates (ParserState defaultState)
        {
            foreach (var nextParserState in this.Where (nsp => !nsp.IsDefault))
            {
                yield return nextParserState;
            }

            var defaultCase = this.FirstOrDefault (nsp => nsp.IsDefault);
            if (defaultCase != null)
            {
                yield return defaultCase;
            }
            else
            {
                yield return new NextParserState (defaultState.Name);
            }
        }

    }

    sealed class NextParserState : BaseEntity<ParserState>
    {
        public readonly string Name         ;
        public readonly string Characters   ;

        public NextParserState (string name, string characters = null)
        {
            Name        = name          ?? S_NoName ;
            Characters  = characters    ?? ""       ;
        }

        public bool IsDefault
        {
            get
            {
                return Characters.Length == 0;
            }
        }
    }

    static string GetCase (char ch)
    {
        switch (ch)
        {
        case '\t':
            return "'\\t'";
        case '\r':
            return "'\\r'";
        case '\n':
            return "'\\n'";
        default:
            return "'" + ch + "'";
        }
    }


#>